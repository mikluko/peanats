// Code generated by mockery. DO NOT EDIT.

package jetstreammock

import (
	context "context"

	jetstream "github.com/nats-io/nats.go/jetstream"
	mock "github.com/stretchr/testify/mock"
)

// Consumer is an autogenerated mock type for the Consumer type
type Consumer struct {
	mock.Mock
}

type Consumer_Expecter struct {
	mock *mock.Mock
}

func (_m *Consumer) EXPECT() *Consumer_Expecter {
	return &Consumer_Expecter{mock: &_m.Mock}
}

// CachedInfo provides a mock function with no fields
func (_m *Consumer) CachedInfo() *jetstream.ConsumerInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CachedInfo")
	}

	var r0 *jetstream.ConsumerInfo
	if rf, ok := ret.Get(0).(func() *jetstream.ConsumerInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.ConsumerInfo)
		}
	}

	return r0
}

// Consumer_CachedInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CachedInfo'
type Consumer_CachedInfo_Call struct {
	*mock.Call
}

// CachedInfo is a helper method to define mock.On call
func (_e *Consumer_Expecter) CachedInfo() *Consumer_CachedInfo_Call {
	return &Consumer_CachedInfo_Call{Call: _e.mock.On("CachedInfo")}
}

func (_c *Consumer_CachedInfo_Call) Run(run func()) *Consumer_CachedInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Consumer_CachedInfo_Call) Return(_a0 *jetstream.ConsumerInfo) *Consumer_CachedInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Consumer_CachedInfo_Call) RunAndReturn(run func() *jetstream.ConsumerInfo) *Consumer_CachedInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Consume provides a mock function with given fields: handler, opts
func (_m *Consumer) Consume(handler jetstream.MessageHandler, opts ...jetstream.PullConsumeOpt) (jetstream.ConsumeContext, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, handler)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Consume")
	}

	var r0 jetstream.ConsumeContext
	var r1 error
	if rf, ok := ret.Get(0).(func(jetstream.MessageHandler, ...jetstream.PullConsumeOpt) (jetstream.ConsumeContext, error)); ok {
		return rf(handler, opts...)
	}
	if rf, ok := ret.Get(0).(func(jetstream.MessageHandler, ...jetstream.PullConsumeOpt) jetstream.ConsumeContext); ok {
		r0 = rf(handler, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ConsumeContext)
		}
	}

	if rf, ok := ret.Get(1).(func(jetstream.MessageHandler, ...jetstream.PullConsumeOpt) error); ok {
		r1 = rf(handler, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_Consume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Consume'
type Consumer_Consume_Call struct {
	*mock.Call
}

// Consume is a helper method to define mock.On call
//   - handler jetstream.MessageHandler
//   - opts ...jetstream.PullConsumeOpt
func (_e *Consumer_Expecter) Consume(handler interface{}, opts ...interface{}) *Consumer_Consume_Call {
	return &Consumer_Consume_Call{Call: _e.mock.On("Consume",
		append([]interface{}{handler}, opts...)...)}
}

func (_c *Consumer_Consume_Call) Run(run func(handler jetstream.MessageHandler, opts ...jetstream.PullConsumeOpt)) *Consumer_Consume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PullConsumeOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PullConsumeOpt)
			}
		}
		run(args[0].(jetstream.MessageHandler), variadicArgs...)
	})
	return _c
}

func (_c *Consumer_Consume_Call) Return(_a0 jetstream.ConsumeContext, _a1 error) *Consumer_Consume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_Consume_Call) RunAndReturn(run func(jetstream.MessageHandler, ...jetstream.PullConsumeOpt) (jetstream.ConsumeContext, error)) *Consumer_Consume_Call {
	_c.Call.Return(run)
	return _c
}

// Fetch provides a mock function with given fields: batch, opts
func (_m *Consumer) Fetch(batch int, opts ...jetstream.FetchOpt) (jetstream.MessageBatch, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, batch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Fetch")
	}

	var r0 jetstream.MessageBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...jetstream.FetchOpt) (jetstream.MessageBatch, error)); ok {
		return rf(batch, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, ...jetstream.FetchOpt) jetstream.MessageBatch); ok {
		r0 = rf(batch, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.MessageBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...jetstream.FetchOpt) error); ok {
		r1 = rf(batch, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_Fetch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fetch'
type Consumer_Fetch_Call struct {
	*mock.Call
}

// Fetch is a helper method to define mock.On call
//   - batch int
//   - opts ...jetstream.FetchOpt
func (_e *Consumer_Expecter) Fetch(batch interface{}, opts ...interface{}) *Consumer_Fetch_Call {
	return &Consumer_Fetch_Call{Call: _e.mock.On("Fetch",
		append([]interface{}{batch}, opts...)...)}
}

func (_c *Consumer_Fetch_Call) Run(run func(batch int, opts ...jetstream.FetchOpt)) *Consumer_Fetch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.FetchOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.FetchOpt)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *Consumer_Fetch_Call) Return(_a0 jetstream.MessageBatch, _a1 error) *Consumer_Fetch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_Fetch_Call) RunAndReturn(run func(int, ...jetstream.FetchOpt) (jetstream.MessageBatch, error)) *Consumer_Fetch_Call {
	_c.Call.Return(run)
	return _c
}

// FetchBytes provides a mock function with given fields: maxBytes, opts
func (_m *Consumer) FetchBytes(maxBytes int, opts ...jetstream.FetchOpt) (jetstream.MessageBatch, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, maxBytes)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FetchBytes")
	}

	var r0 jetstream.MessageBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...jetstream.FetchOpt) (jetstream.MessageBatch, error)); ok {
		return rf(maxBytes, opts...)
	}
	if rf, ok := ret.Get(0).(func(int, ...jetstream.FetchOpt) jetstream.MessageBatch); ok {
		r0 = rf(maxBytes, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.MessageBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...jetstream.FetchOpt) error); ok {
		r1 = rf(maxBytes, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_FetchBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchBytes'
type Consumer_FetchBytes_Call struct {
	*mock.Call
}

// FetchBytes is a helper method to define mock.On call
//   - maxBytes int
//   - opts ...jetstream.FetchOpt
func (_e *Consumer_Expecter) FetchBytes(maxBytes interface{}, opts ...interface{}) *Consumer_FetchBytes_Call {
	return &Consumer_FetchBytes_Call{Call: _e.mock.On("FetchBytes",
		append([]interface{}{maxBytes}, opts...)...)}
}

func (_c *Consumer_FetchBytes_Call) Run(run func(maxBytes int, opts ...jetstream.FetchOpt)) *Consumer_FetchBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.FetchOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.FetchOpt)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *Consumer_FetchBytes_Call) Return(_a0 jetstream.MessageBatch, _a1 error) *Consumer_FetchBytes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_FetchBytes_Call) RunAndReturn(run func(int, ...jetstream.FetchOpt) (jetstream.MessageBatch, error)) *Consumer_FetchBytes_Call {
	_c.Call.Return(run)
	return _c
}

// FetchNoWait provides a mock function with given fields: batch
func (_m *Consumer) FetchNoWait(batch int) (jetstream.MessageBatch, error) {
	ret := _m.Called(batch)

	if len(ret) == 0 {
		panic("no return value specified for FetchNoWait")
	}

	var r0 jetstream.MessageBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (jetstream.MessageBatch, error)); ok {
		return rf(batch)
	}
	if rf, ok := ret.Get(0).(func(int) jetstream.MessageBatch); ok {
		r0 = rf(batch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.MessageBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(batch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_FetchNoWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchNoWait'
type Consumer_FetchNoWait_Call struct {
	*mock.Call
}

// FetchNoWait is a helper method to define mock.On call
//   - batch int
func (_e *Consumer_Expecter) FetchNoWait(batch interface{}) *Consumer_FetchNoWait_Call {
	return &Consumer_FetchNoWait_Call{Call: _e.mock.On("FetchNoWait", batch)}
}

func (_c *Consumer_FetchNoWait_Call) Run(run func(batch int)) *Consumer_FetchNoWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Consumer_FetchNoWait_Call) Return(_a0 jetstream.MessageBatch, _a1 error) *Consumer_FetchNoWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_FetchNoWait_Call) RunAndReturn(run func(int) (jetstream.MessageBatch, error)) *Consumer_FetchNoWait_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with given fields: _a0
func (_m *Consumer) Info(_a0 context.Context) (*jetstream.ConsumerInfo, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *jetstream.ConsumerInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*jetstream.ConsumerInfo, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *jetstream.ConsumerInfo); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.ConsumerInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type Consumer_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *Consumer_Expecter) Info(_a0 interface{}) *Consumer_Info_Call {
	return &Consumer_Info_Call{Call: _e.mock.On("Info", _a0)}
}

func (_c *Consumer_Info_Call) Run(run func(_a0 context.Context)) *Consumer_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Consumer_Info_Call) Return(_a0 *jetstream.ConsumerInfo, _a1 error) *Consumer_Info_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_Info_Call) RunAndReturn(run func(context.Context) (*jetstream.ConsumerInfo, error)) *Consumer_Info_Call {
	_c.Call.Return(run)
	return _c
}

// Messages provides a mock function with given fields: opts
func (_m *Consumer) Messages(opts ...jetstream.PullMessagesOpt) (jetstream.MessagesContext, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Messages")
	}

	var r0 jetstream.MessagesContext
	var r1 error
	if rf, ok := ret.Get(0).(func(...jetstream.PullMessagesOpt) (jetstream.MessagesContext, error)); ok {
		return rf(opts...)
	}
	if rf, ok := ret.Get(0).(func(...jetstream.PullMessagesOpt) jetstream.MessagesContext); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.MessagesContext)
		}
	}

	if rf, ok := ret.Get(1).(func(...jetstream.PullMessagesOpt) error); ok {
		r1 = rf(opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_Messages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Messages'
type Consumer_Messages_Call struct {
	*mock.Call
}

// Messages is a helper method to define mock.On call
//   - opts ...jetstream.PullMessagesOpt
func (_e *Consumer_Expecter) Messages(opts ...interface{}) *Consumer_Messages_Call {
	return &Consumer_Messages_Call{Call: _e.mock.On("Messages",
		append([]interface{}{}, opts...)...)}
}

func (_c *Consumer_Messages_Call) Run(run func(opts ...jetstream.PullMessagesOpt)) *Consumer_Messages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PullMessagesOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PullMessagesOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Consumer_Messages_Call) Return(_a0 jetstream.MessagesContext, _a1 error) *Consumer_Messages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_Messages_Call) RunAndReturn(run func(...jetstream.PullMessagesOpt) (jetstream.MessagesContext, error)) *Consumer_Messages_Call {
	_c.Call.Return(run)
	return _c
}

// Next provides a mock function with given fields: opts
func (_m *Consumer) Next(opts ...jetstream.FetchOpt) (jetstream.Msg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Next")
	}

	var r0 jetstream.Msg
	var r1 error
	if rf, ok := ret.Get(0).(func(...jetstream.FetchOpt) (jetstream.Msg, error)); ok {
		return rf(opts...)
	}
	if rf, ok := ret.Get(0).(func(...jetstream.FetchOpt) jetstream.Msg); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Msg)
		}
	}

	if rf, ok := ret.Get(1).(func(...jetstream.FetchOpt) error); ok {
		r1 = rf(opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Consumer_Next_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Next'
type Consumer_Next_Call struct {
	*mock.Call
}

// Next is a helper method to define mock.On call
//   - opts ...jetstream.FetchOpt
func (_e *Consumer_Expecter) Next(opts ...interface{}) *Consumer_Next_Call {
	return &Consumer_Next_Call{Call: _e.mock.On("Next",
		append([]interface{}{}, opts...)...)}
}

func (_c *Consumer_Next_Call) Run(run func(opts ...jetstream.FetchOpt)) *Consumer_Next_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.FetchOpt, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.FetchOpt)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Consumer_Next_Call) Return(_a0 jetstream.Msg, _a1 error) *Consumer_Next_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Consumer_Next_Call) RunAndReturn(run func(...jetstream.FetchOpt) (jetstream.Msg, error)) *Consumer_Next_Call {
	_c.Call.Return(run)
	return _c
}

// NewConsumer creates a new instance of Consumer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConsumer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Consumer {
	mock := &Consumer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
